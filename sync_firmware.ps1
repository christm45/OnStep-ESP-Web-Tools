# Automatically generate manifests for each .bin in firmware/ then regenerate manifest_list.js
# Usage: .\sync_firmware.ps1

param()

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

$script:LaunchedByExplorer = $false
try {
  $ppid = (Get-CimInstance Win32_Process -Filter "ProcessId=$PID").ParentProcessId
  $pname = (Get-Process -Id $ppid -ErrorAction SilentlyContinue).ProcessName
  $script:LaunchedByExplorer = $pname -eq 'explorer'
} catch {}
function Test-ExplorerLaunch {
  param([int]$StartPid = $PID)
  try {
    $current = Get-CimInstance Win32_Process -Filter "ProcessId=$StartPid"
    for ($i=0; $i -lt 5 -and $null -ne $current; $i++) {
      $name = $current.Name
      if ($name -eq 'explorer.exe') { return $true }
      if ($current.ParentProcessId -le 0) { break }
      $current = Get-CimInstance Win32_Process -Filter "ProcessId=$($current.ParentProcessId)"
    }
  } catch {}
  return $false
}
$script:LaunchedByExplorer = $script:LaunchedByExplorer -or (Test-ExplorerLaunch -StartPid $PID)
trap {
  Write-Host ("ERROR: " + $_.Exception.Message) -ForegroundColor Red
  if ($script:LaunchedByExplorer) { Read-Host "Press Enter to close this window" }
  break
}

$root = $PSScriptRoot
$firmwareDir = Join-Path $root 'firmware'
$manifestDir = Join-Path $root 'manifest'

if (-not (Test-Path $firmwareDir)) {
  New-Item -ItemType Directory -Force -Path $firmwareDir | Out-Null
}
if (-not (Test-Path $manifestDir)) {
  New-Item -ItemType Directory -Force -Path $manifestDir | Out-Null
}

function New-ManifestFromBin {
  param(
    [string]$BinPath
  )
  $binName = [System.IO.Path]::GetFileNameWithoutExtension($BinPath)  # ex: FYSETC_E4_10.24c
  # Version = apr√®s le dernier underscore
  $idx = $binName.LastIndexOf('_')
  if ($idx -le 0) {
    Write-Host ("Skipped (unexpected name): " + $binName) -ForegroundColor Yellow
    return
  }
  $projectSlug = $binName.Substring(0, $idx)       # ex: FYSETC_E4
  $version = $binName.Substring($idx + 1)          # ex: 10.24c
  $projectName = $projectSlug -replace '_',' '     # ex: FYSETC E4
  $manifestFile = Join-Path $manifestDir ("manifest_" + $binName + ".json")

  if (Test-Path $manifestFile) {
    Write-Host ("Manifest already exists: " + (Split-Path $manifestFile -Leaf)) -ForegroundColor DarkGray
    return
  }

  $content = @{
    name    = $projectName
    version = $version
    builds  = @(
      @{
        chipFamily = 'ESP32'
        parts = @(
          @{
            path = "firmware/$($binName).bin"
            offset = 0
          }
        )
      }
    )
  } | ConvertTo-Json -Depth 10

  Set-Content -Path $manifestFile -Value $content -Encoding UTF8
  Write-Host ("Created: " + (Split-Path $manifestFile -Leaf)) -ForegroundColor Green
}

Get-ChildItem -Path $firmwareDir -Filter *.bin -File | ForEach-Object {
  New-ManifestFromBin -BinPath $_.FullName
}

# Remove orphaned manifests (manifests without corresponding .bin files)
Write-Host "Checking for orphaned manifests..." -ForegroundColor Cyan
$existingBins = @{}
Get-ChildItem -Path $firmwareDir -Filter *.bin -File | ForEach-Object {
  $binName = $_.BaseName
  $existingBins[$binName] = $true
}

$orphanedCount = 0
Get-ChildItem -Path $manifestDir -Filter "manifest_*.json" | ForEach-Object {
  $manifestName = $_.BaseName
  if ($manifestName -match '^manifest_(.+)$') {
    $binName = $matches[1]
    if (-not $existingBins.ContainsKey($binName)) {
      Remove-Item -Path $_.FullName -Force
      Write-Host ("Removed orphaned manifest: " + $_.Name) -ForegroundColor Yellow
      $orphanedCount++
    }
  }
}
if ($orphanedCount -gt 0) {
  Write-Host ("Removed {0} orphaned manifest(s)" -f $orphanedCount) -ForegroundColor Green
}

# Regenerate manifest_list.js for the UI (only for manifests with existing .bin files)
Write-Host "Generating manifest_list.js ..." -ForegroundColor Cyan
$manifestFiles = Get-ChildItem -Path $manifestDir -Filter "*.json" | Sort-Object Name
$manifestList = @()
foreach ($m in $manifestFiles) {
  # Verify the .bin file exists before adding to list
  try {
    $content = Get-Content -Path $m.FullName -Raw | ConvertFrom-Json
    $binPath = $content.builds[0].parts[0].path
    $fullBinPath = Join-Path $root $binPath
    if (Test-Path $fullBinPath) {
      $manifestList += "manifest/$($m.Name)"
    } else {
      Write-Host ("Skipping manifest with missing .bin: " + $m.Name) -ForegroundColor Yellow
    }
  } catch {
    Write-Host ("Skipping invalid manifest: " + $m.Name) -ForegroundColor Yellow
  }
}

$manifestListJs = $manifestList | ForEach-Object { "  '$_'," }
$jsContent = @"
// Available manifests - Auto-generated by sync_firmware.ps1
// Do not edit manually. Re-run sync_firmware.ps1 to regenerate.
export const MANIFEST_FILES = [
$($manifestListJs -join "`n")
];
"@

Set-Content -Path (Join-Path $root 'manifest_list.js') -Value $jsContent -Encoding UTF8
Write-Host ("manifest_list.js created with {0} manifests" -f $manifestList.Count) -ForegroundColor Green

Write-Host "Sync completed." -ForegroundColor Green

# Pause if launched from Explorer
try {
  $parent = (Get-CimInstance Win32_Process -Filter "ProcessId=$PID").ParentProcessId
  $parentName = (Get-Process -Id $parent -ErrorAction SilentlyContinue).ProcessName
  if ($parentName -eq 'explorer') { Read-Host "Press Enter to close this window" }
} catch {}

